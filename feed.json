{
    "version": "https://jsonfeed.org/version/1",
    "title": "时光∞记忆碎片",
    "description": "Starlight spread the universe",
    "home_page_url": "https://killer1214.github.io",
    "items": [
        {
            "id": "https://killer1214.github.io/2023/04/04/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "url": "https://killer1214.github.io/2023/04/04/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "title": "c++面向对象",
            "date_published": "2023-04-04T08:39:03.000Z",
            "content_html": "<h1 id=\"c核心编程\"><a class=\"anchor\" href=\"#c核心编程\">#</a> c++ 核心编程</h1>\n<p>主要针对 c++ 面向对象编程技术</p>\n<h2 id=\"1-内存分区模型\"><a class=\"anchor\" href=\"#1-内存分区模型\">#</a> 1 内存分区模型</h2>\n<p>c++ 程序在执行时，将内存大方向划分为<strong> 4 个区域</strong></p>\n<ul>\n<li>\n<p>代码区，存放函数体的二进制代码，由操作系统进行管理</p>\n</li>\n<li>\n<p>全局区，存放和静态变量以及常量</p>\n</li>\n<li>\n<p>栈区，由编译器自动分配释放，存放函数的参数值，局部变量等</p>\n</li>\n<li>\n<p>堆区，由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</p>\n</li>\n</ul>\n<p><strong>内存四区意义：</strong></p>\n<p>不同区域存放的数据，赋予不同的生命周期，更灵活编程</p>\n<h3 id=\"11-程序运行前\"><a class=\"anchor\" href=\"#11-程序运行前\">#</a> 1.1 程序运行前</h3>\n<p>在程序编译后，生成了 <code>.exe</code>  可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>\n<p><strong>代码区：</strong></p>\n<ul>\n<li>\n<p>存放 CPU 执行的机器指令</p>\n</li>\n<li>\n<p>代码区是<strong>共享的</strong>，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n</li>\n<li>\n<p>代码是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了他的指令</p>\n</li>\n</ul>\n<p><strong>全局区：</strong></p>\n<ul>\n<li>\n<p>全局变量和静态变量存放在此</p>\n</li>\n<li>\n<p>全局区还包含了常量区，字符串常量和其他常量（const 修饰）也存放在此</p>\n</li>\n<li>\n<p>该区域的数据在程序结束后由操作系统释放</p>\n</li>\n</ul>\n<p>全局变量：在函数体外定义的变量</p>\n<p>静态变量： <code>static 数据类型 变量名</code></p>\n<p>常量：</p>\n<ul>\n<li>\n<p>字符串常量：&quot;hello world&quot;</p>\n</li>\n<li>\n<p>const 修饰的变量</p>\n<ul>\n<li>\n<p>const 修饰的全局变量 --&gt; 全局常量</p>\n</li>\n<li>\n<p>const 修饰的局部变量 --&gt; 局部常量（不存放在全局区）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"12-程序运行后\"><a class=\"anchor\" href=\"#12-程序运行后\">#</a> 1.2 程序运行后</h3>\n<p><strong>栈区：</strong></p>\n<ul>\n<li>由编译器自动分配释放，存放函数的参数值，局部变量等</li>\n</ul>\n<blockquote>\n<p>注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n</blockquote>\n<ul>\n<li>栈区的数据在函数执行完后自动释放（第一次可以正确查看，是因为编译器做了保留，第二次就不会保留了）</li>\n</ul>\n<p><strong>堆区：</strong></p>\n<ul>\n<li>\n<p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p>\n</li>\n<li>\n<p>在 C++ 中主要利用 new 在堆区开辟内存（返回创建数据的地址）</p>\n</li>\n</ul>\n<p><code>int *a = new int(10);</code></p>\n<h3 id=\"13-new操作符\"><a class=\"anchor\" href=\"#13-new操作符\">#</a> 1.3 new 操作符</h3>\n<p>c++ 利用 new 操作符在堆区开辟数据</p>\n<p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete</p>\n<p>语法： <code>new 数据类型</code></p>\n<p>利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n<p>new 创建数组： <code>int *arr = new int[10];</code> 10 代表数组有十个元素</p>\n<p>释放数组： <code>delete[] arr;</code></p>\n<h2 id=\"2-引用\"><a class=\"anchor\" href=\"#2-引用\">#</a> 2 引用</h2>\n<h3 id=\"21-引用的基本使用\"><a class=\"anchor\" href=\"#21-引用的基本使用\">#</a> 2.1 引用的基本使用</h3>\n<p>作用：给变量起别名</p>\n<p>语法： <code>数据类型 &amp;别名 = 原名</code></p>\n<p>引用必须引一块合法的内存空间，栈区和堆区</p>\n<p>错误： <code>int &amp; ref = 10;</code></p>\n<p>正确： <code>const int &amp; ref = 10; 编译器将代码修改(int temp = 10;const int &amp; ref = 10;)</code> （注意此时 ref 指向的值不可以修改，并且 ref 也不可以引用别的变量）相当于 <code>int a=10; const int * const ref = &amp;a;</code></p>\n<h3 id=\"22-引用的注意事项\"><a class=\"anchor\" href=\"#22-引用的注意事项\">#</a> 2.2 引用的注意事项</h3>\n<ul>\n<li>\n<p>必须初始化</p>\n</li>\n<li>\n<p>在初始化后，不可以改变</p>\n</li>\n</ul>\n<h3 id=\"23-引用做函数参数\"><a class=\"anchor\" href=\"#23-引用做函数参数\">#</a> 2.3 引用做函数参数</h3>\n<p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p>优点：可以简化指针修改实参</p>\n<p>如： <code>void swap(int &amp;a, int &amp;b)</code></p>\n<p>对比指针： <code>void swap(int *a, int *b)</code></p>\n<h3 id=\"24-引用做函数返回值\"><a class=\"anchor\" href=\"#24-引用做函数返回值\">#</a> 2.4 引用做函数返回值</h3>\n<p>作用：引用时可以作为函数的返回值存在的</p>\n<p>注意：<strong>不要返回局部变量引用</strong>（局部变量会在函数执行结束后释放）</p>\n<p>用法：函数调用可以作为左值</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> <span class=\"token function\">test01</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token comment\">// 非法操作，a 为局部变量</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> <span class=\"token function\">test02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token comment\">// 合法，此时 a 为静态变量，存放在全局区</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">test02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 合法，test02 () 相当于 a，此时 a 为 1000</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> ref <span class=\"token operator\">=</span> <span class=\"token function\">test02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//ref 为 1000</span></pre></td></tr></table></figure><h3 id=\"25-引用的本质\"><a class=\"anchor\" href=\"#25-引用的本质\">#</a> 2.5 引用的本质</h3>\n<p>本质：引用的本质在 C++ 内部实现是一个指针常量 (指向不可改，值可以改)</p>\n<p><code>int&amp; ref = a; 相当于 int* const ref = &amp;a;</code></p>\n<p>结论：C++ 推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<h3 id=\"26-常量引用\"><a class=\"anchor\" href=\"#26-常量引用\">#</a> 2.6 常量引用</h3>\n<p>作用：常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加 const 修饰形参，防止形参改变实参</p>\n<p>常量引用相当于 const 既修饰常量又修饰指针</p>\n<h2 id=\"3-函数提高\"><a class=\"anchor\" href=\"#3-函数提高\">#</a> 3 函数提高</h2>\n<h3 id=\"31-函数默认参数\"><a class=\"anchor\" href=\"#31-函数默认参数\">#</a> 3.1 函数默认参数</h3>\n<p>在 c++ 中，函数的形参列表中的形参是可以有默认值的</p>\n<p>语法： <code>返回值类型 函数名 (参数=默认值)&#123;&#125;</code></p>\n<p>注意：</p>\n<blockquote>\n<ul>\n<li>\n<p>如果某个位置参数有默认值，那么从这个位置往后，从左往右的参数都要有默认值</p>\n</li>\n<li>\n<p>声明和实现只能有一个有默认参数，否则二义性，非法操作</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"32-函数占位参数\"><a class=\"anchor\" href=\"#32-函数占位参数\">#</a> 3.2 函数占位参数</h3>\n<p>c++ 中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>语法： <code>返回值类型 函数名(数据类型)&#123;&#125;</code></p>\n<p>如： <code>void func(int a, int)&#123;&#125;</code></p>\n<p>调用： <code>func(10,20);</code></p>\n<p>占位参数还可以有默认参数，如： <code>void func(int a, int =10)&#123;&#125;</code></p>\n<h3 id=\"33-函数重载\"><a class=\"anchor\" href=\"#33-函数重载\">#</a> 3.3 函数重载</h3>\n<h4 id=\"331-函数重载概述\"><a class=\"anchor\" href=\"#331-函数重载概述\">#</a> 3.3.1 函数重载概述</h4>\n<p>作用：函数名可以相同，提高复用性</p>\n<p><strong>函数重载满足条件：</strong></p>\n<ul>\n<li>\n<p>同一个作用域下</p>\n</li>\n<li>\n<p>函数名相同</p>\n</li>\n<li>\n<p>函数参数<strong>类型不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong></p>\n</li>\n</ul>\n<p>注意：函数的返回值不同不可以作为函数重载条件</p>\n<h4 id=\"332-函数重载注意事项\"><a class=\"anchor\" href=\"#332-函数重载注意事项\">#</a> 3.3.2 函数重载注意事项</h4>\n<ul>\n<li>\n<p>引用作为重载条件，const 进行修饰可以进行重载</p>\n</li>\n<li>\n<p>函数重载碰到函数默认参数</p>\n</li>\n</ul>\n<blockquote>\n<p>void func1 (int a) 和 void func1 (int a,int b=10) 在传递一个参数时重载错误，传递两个参数时可以重载，但是尽量避免此情况</p>\n</blockquote>\n<h2 id=\"4-类和对象\"><a class=\"anchor\" href=\"#4-类和对象\">#</a> 4 类和对象</h2>\n<p>C++ 面向对象的三大特性为：封装、继承、多态</p>\n<p>C++ 认为万事万物皆为对象，对象上有其属性和行为</p>\n<p>例如：</p>\n<p>人可以作为对象，属性有姓名，年龄，身高，体重、、行为有走、跑、跳...</p>\n<p>车也可以作为对象，属性有轮胎，方向盘，车灯、、行为有载人，放音乐，开空调、、</p>\n<p><strong>具有相同性质的对象</strong>，我们可以抽象为类，人属于人类，车属于车类</p>\n<h3 id=\"41-封装\"><a class=\"anchor\" href=\"#41-封装\">#</a> 4.1 封装</h3>\n<h4 id=\"411-封装的意义\"><a class=\"anchor\" href=\"#411-封装的意义\">#</a> 4.1.1 封装的意义</h4>\n<ul>\n<li>\n<p>将属性和行为作为一个整体，表现生活中的事物</p>\n</li>\n<li>\n<p>将属性和行为加以权限控制</p>\n</li>\n</ul>\n<p><strong>封装意义一：</strong></p>\n<p>在设计类的时候，属性和行为写在一起，表现事物</p>\n<p>语法： <code>class 类名&#123;访问权限：属性/行为&#125;；</code></p>\n<p>示例 1：设计一个圆类，求圆的周长</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 圆周率</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> PI <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 设计一个圆类，求圆的周长</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 圆求周长的公式：2*PI * 半径</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Circle</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// 属性</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">double</span> m_r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">// 行为</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">double</span> <span class=\"token function\">calculateZC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> PI <span class=\"token operator\">*</span> m_r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token comment\">// 通过圆类，创建具体的圆（对象）</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    Circle c1<span class=\"token punctuation\">;</span><span class=\"token comment\">// 实例化</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token comment\">//c1.m_r = 10;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"输入圆的半径：\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    cin <span class=\"token operator\">>></span> c1<span class=\"token punctuation\">.</span>m_r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"圆的周长:\"</span> <span class=\"token operator\">&lt;&lt;</span> c1<span class=\"token punctuation\">.</span><span class=\"token function\">calculateZC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token function\">system</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pause\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>类中的属性和行为，我们统一称为 <strong>成员</strong></p>\n<ul>\n<li>\n<p>属性    成员属性 成员变量</p>\n</li>\n<li>\n<p>行为    成员函数 成员方法</p>\n</li>\n</ul>\n<p><strong>封装的意义二：</strong></p>\n<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<table>\n<thead>\n<tr>\n<th>public</th>\n<th>公共权限</th>\n<th>类内可以访问</th>\n<th>类外可以访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>protected</td>\n<td>保护权限</td>\n<td>类内可以访问</td>\n<td>类外不可以访问</td>\n</tr>\n<tr>\n<td>private</td>\n<td>私有权限</td>\n<td>类内可以访问</td>\n<td>类外不可以访问</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>保护权限，子类可以访问父类；私有权限，子类不可访问父类</p>\n</blockquote>\n<h4 id=\"412-struct和class区别\"><a class=\"anchor\" href=\"#412-struct和class区别\">#</a> 4.1.2 struct 和 class 区别</h4>\n<p>唯一区别在于默认的访问权限不同，struct 默认是公共权限，class 默认是私有权限</p>\n<h4 id=\"413-成员属性设置为私有\"><a class=\"anchor\" href=\"#413-成员属性设置为私有\">#</a> 4.1.3 成员属性设置为私有</h4>\n<p>优点：</p>\n<ul>\n<li>\n<p>将所有成员属性设置为私有，可以自己控制读写权限</p>\n</li>\n<li>\n<p>对于写权限，我们可以检测数据的有效性</p>\n</li>\n</ul>\n<p>案例 1：使用全局函数和成员函数分别判断两个立方体是否相等</p>\n<p>案例 2：点和圆的位置关系</p>\n<h3 id=\"42-对象的初始化和清理\"><a class=\"anchor\" href=\"#42-对象的初始化和清理\">#</a> 4.2 对象的初始化和清理</h3>\n<ul>\n<li>\n<p>生活中的电子设备基本都有出厂设置</p>\n</li>\n<li>\n<p>c++ 中的面向对象来源于生活，每个对象也都会有初始设置，以及对象销毁前的清理数据的设置。</p>\n</li>\n</ul>\n<h4 id=\"421-构造函数和析构函数\"><a class=\"anchor\" href=\"#421-构造函数和析构函数\">#</a> 4.2.1 构造函数和析构函数</h4>\n<p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题：</p>\n<p>一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>同样，使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>\n<p>c++ 利用<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数会被编译器自动调用，完成对象的初始化和清理工作。对象的初始化和清理工作是编译器强制做的事情。因此，<strong>如果不提供这两个函数，编译器会提供空实现</strong></p>\n<ul>\n<li>\n<p>构造函数：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用</p>\n</li>\n<li>\n<p>析构函数：作用于对象<strong>销毁前</strong>系统自动调用，执行清理工作。</p>\n</li>\n</ul>\n<p><strong>构造函数语法：</strong> <code>类名()&#123;&#125;</code></p>\n<ol>\n<li>\n<p>构造函数，没有返回值也不写 void</p>\n</li>\n<li>\n<p>函数名和类名相同</p>\n</li>\n<li>\n<p>构造函数可以有参数，因此可以发生重载</p>\n</li>\n<li>\n<p>程序在调用对象时候会自动调用构造，无须手动，而且只调用一次</p>\n</li>\n</ol>\n<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>\n<ol>\n<li>\n<p>析构函数，没有返回值也不写 void</p>\n</li>\n<li>\n<p>函数名称与类名相同，在名称前加上符号 <code>~</code></p>\n</li>\n<li>\n<p>析构函数不可以有参数，因此不可以发生重载</p>\n</li>\n<li>\n<p>程序在对象销毁前自动调用析构， 无须手动，且只调用一次</p>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 对象的初始化和清理</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">//1. 构造函数，进行初始化</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 构造函数</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Person构造函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// 析构函数</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token operator\">~</span><span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Person析构函数调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">test01</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    Person p<span class=\"token punctuation\">;</span><span class=\"token comment\">// 局部变量，栈区，test01 () 执行完后就会释放</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token comment\">//test01();</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    Person p1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token function\">system</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pause\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"422-构造函数的分类及调用\"><a class=\"anchor\" href=\"#422-构造函数的分类及调用\">#</a> 4.2.2 构造函数的分类及调用</h4>\n<p>两种分类方式：</p>\n<ul>\n<li>\n<p>按参数：有参构造和无参构造</p>\n</li>\n<li>\n<p>按类型：普通构造和拷贝构造</p>\n</li>\n</ul>\n<p>三种调用方式：</p>\n<ul>\n<li>\n<p>括号法</p>\n</li>\n<li>\n<p>显示法</p>\n</li>\n<li>\n<p>隐式转换法</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 构造函数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 无参，默认构造函数</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Person无参构造函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 有参构造函数</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        age <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Person有参构造函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 拷贝构造函数</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Person <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token comment\">// 将传入的人身上所有属性，拷贝到我身上</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        age <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>调用方式：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//1. 括号法</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    Person p1<span class=\"token punctuation\">;</span><span class=\"token comment\">// 无参</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    Person <span class=\"token function\">p2</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 有参</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    Person <span class=\"token function\">p3</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 拷贝</span></pre></td></tr></table></figure><p>注意：调用默认构造函数时，不要加 ()</p>\n<p><code>Person p1();</code>  被认为是一个函数声明</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//2. 显示法</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    Person p1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    Person p2 <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    Person p3 <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>其中右侧的 <code>Person(10)</code>  称作匿名对象</p>\n<p>特点：当前行 执行结束，系统会立即回收掉匿名对象</p>\n<p>注意：不要利用拷贝构造函数，初始化匿名对象；</p>\n<p><code>Person(p3)</code> // 编译器认为 <code>Person(p3);====Person p3;</code> ，是对象的声明</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//3. 隐式转换法</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    Person p4 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    Person p5 <span class=\"token operator\">=</span> p4<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"423-拷贝构造函数调用时机\"><a class=\"anchor\" href=\"#423-拷贝构造函数调用时机\">#</a> 4.2.3 拷贝构造函数调用时机</h4>\n<p>c++ 中拷贝构造函数调用时机通常有三种情况：</p>\n<ul>\n<li>\n<p>使用一个已经创建完毕的对象来初始化一个新对象</p>\n</li>\n<li>\n<p>值传递的方式给函数参数传值</p>\n</li>\n<li>\n<ul>\n<li>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">work</span><span class=\"token punctuation\">(</span>Person p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    p<span class=\"token punctuation\">.</span>m_age <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">test02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    Person <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">work</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"p的年龄:\"</span> <span class=\"token operator\">&lt;&lt;</span> p<span class=\"token punctuation\">.</span>m_age <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>以值方式返回局部对象，返回对象时，调用拷贝对象，将值传回</p>\n</li>\n</ul>\n<p>在不写拷贝构造函数时，执行上述操作时，编译器也会自动执行拷贝</p>\n<h4 id=\"424-构造函数调用规则\"><a class=\"anchor\" href=\"#424-构造函数调用规则\">#</a> 4.2.4 构造函数调用规则</h4>\n<p>默认情况下，c++ 编译器至少给一个类添加 3 个函数</p>\n<ol>\n<li>\n<p>默认构造函数（无参，函数体为空）</p>\n</li>\n<li>\n<p>默认析构函数（函数体为空）</p>\n</li>\n<li>\n<p>默认拷贝函数，对属性进行值拷贝</p>\n</li>\n</ol>\n<p>调用规则：</p>\n<ul>\n<li>\n<p>如果用户定义有参构造，c++ 不在提供默认无参构造，但是会提供默认拷贝</p>\n</li>\n<li>\n<p>如果用户定义拷贝构造，c++ 不会再提供其他构造函数</p>\n</li>\n</ul>\n<h4 id=\"425-深拷贝和浅拷贝\"><a class=\"anchor\" href=\"#425-深拷贝和浅拷贝\">#</a> 4.2.5 深拷贝和浅拷贝</h4>\n<p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<ul>\n<li>\n<p>浅拷贝带来的问题就是堆区的内存重复释放，利用深拷贝进行解决</p>\n</li>\n<li>\n<p>深拷贝，重新申请了另外一块堆区内存</p>\n</li>\n</ul>\n<p>总结：</p>\n<blockquote>\n<p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n</blockquote>\n<h4 id=\"426-初始化列表\"><a class=\"anchor\" href=\"#426-初始化列表\">#</a> 4.2.6 初始化列表</h4>\n<p>作用：c++ 提供了初始化列表语法，用来初始化属性</p>\n<p>语法： <code>构造函数():属性1(值1)属性2(值2)...&#123;&#125;</code></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token function\">m_A</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">m_B</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">m_C</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">int</span> m_A<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">int</span> m_B<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">int</span> m_C<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    Person <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"427-类对象作为类成员\"><a class=\"anchor\" href=\"#427-类对象作为类成员\">#</a> 4.2.7 类对象作为类成员</h4>\n<p>c++ 类中的成员可以时另外一个类的对象</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    A a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>B 类中有对象 a 作为成员，a 为对象成员</p>\n<p>先构造了对象 a；当其他类的对象作为本类成员，构造时候先构造其他类对象，再构造自身</p>\n<p>析构时，先释放自身，再释放包含的其他类对象</p>\n<h4 id=\"428-静态成员\"><a class=\"anchor\" href=\"#428-静态成员\">#</a> 4.2.8 静态成员</h4>\n<p>静态成员就是在成员变量和成员函数前加上关键字 static, 称为静态成员</p>\n<p>分为：</p>\n<ul>\n<li>\n<p>静态成员变量</p>\n<ul>\n<li>\n<p>所有对象共享同一份数据</p>\n</li>\n<li>\n<p>在编译阶段分配内存</p>\n</li>\n<li>\n<p>类内声明，类外初始化</p>\n</li>\n</ul>\n</li>\n<li>\n<p>静态成员函数</p>\n<ul>\n<li>\n<p>所有对象共享同一个函数</p>\n</li>\n<li>\n<p>静态成员函数只能访问静态成员变量</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> m_A<span class=\"token punctuation\">;</span><span class=\"token comment\">// 类内声明</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 静态成员变量也是有访问权限的</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> Person<span class=\"token double-colon punctuation\">::</span>m_A <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 类外初始化</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">test01</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    Person p<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> p<span class=\"token punctuation\">.</span>m_A <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    Person p2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    p2<span class=\"token punctuation\">.</span>m_A <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> p<span class=\"token punctuation\">.</span>m_A <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>静态成员变量的两种访问</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">test02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 静态成员变量，不属于某个对象</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 因此有两种访问方式</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">//1. 通过对象访问</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    Person p<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> p<span class=\"token punctuation\">.</span>m_A <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">//2. 通过类名访问</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> Person<span class=\"token double-colon punctuation\">::</span>m_A <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意：静态成员变量也受权限约束，处于 private 约束下的不能在类外访问，但可在全局进行初始化</p>\n<p>静态成员函数的访问和静态成员变量的访问方式可类比，也受到 private 约束</p>\n<h3 id=\"43-c对象模型和this指针\"><a class=\"anchor\" href=\"#43-c对象模型和this指针\">#</a> 4.3 c++ 对象模型和 this 指针</h3>\n<h4 id=\"431-成员变量和成员函数分开存储\"><a class=\"anchor\" href=\"#431-成员变量和成员函数分开存储\">#</a> 4.3.1 成员变量和成员函数分开存储</h4>\n<p>在 c++ 中，类内成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<blockquote>\n<p>空对象占用内存空间为：1</p>\n<p>c++ 编译器会给每个空对象分配一个字节空间，为了区分空对象占内存的位置</p>\n<p>每个空对象也有一个独一无二的内存地址</p>\n</blockquote>\n<h4 id=\"432-this指针概念\"><a class=\"anchor\" href=\"#432-this指针概念\">#</a> 4.3.2 this 指针概念</h4>\n<p>c++ 中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数指挥诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<p>问题是：这一块代码如何区分哪个对象调用自己的呢？</p>\n<p>c++ 提供特殊的对象指针，this 指针，解决上述问题。<strong>this 指针指向被调用的成员函数所属的对象</strong></p>\n<p>this 指针是隐含在每一个非静态成员函数内的一种指针</p>\n<p>this 指针不需要定义，直接使用即可</p>\n<p>this 指针的用途：</p>\n<ul>\n<li>\n<p>当形参和成员变量同名时，可用 this 指针来区分</p>\n</li>\n<li>\n<p>在类的非静态成员函数中返回对象本身，可使用 <code>return *this;</code></p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 使用引用返回，不然会创建新的对象接收数据</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    Person<span class=\"token operator\">&amp;</span> <span class=\"token function\">PerAddPer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Person<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>age <span class=\"token operator\">+=</span> p<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 返回该对象本体</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"433-空指针访问成员函数\"><a class=\"anchor\" href=\"#433-空指针访问成员函数\">#</a> 4.3.3 空指针访问成员函数</h4>\n<p>c++ 中空指针也可以调用成员函数，但是也要注意有没有用到 this 指针</p>\n<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>\n<p>空指针可以访问成员，但是不能访问属性</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">test01</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    Person<span class=\"token operator\">*</span> p <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">//p->showClassName();</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    p<span class=\"token operator\">-></span><span class=\"token function\">showPersonAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>一般在访问属性前的成员函数内部增添判断语句，增加代码的健壮性</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">showPersonAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token comment\">// 因为传入的指针为 NULL，所以访问属性出错</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token comment\">// 增加代码的健壮性</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"age = \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m_age <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"434-const修饰成员函数\"><a class=\"anchor\" href=\"#434-const修饰成员函数\">#</a> 4.3.4 const 修饰成员函数</h4>\n<p><strong>常函数：</strong></p>\n<ul>\n<li>\n<p>成员函数后加 const，称为常函数 // 本质是修饰 this, const Person * const this</p>\n</li>\n<li>\n<p>常函数内不可以修改成员属性</p>\n</li>\n<li>\n<p>成员属性声明时加关键字 <code>mutable</code>  后，在常函数中依然可以修改</p>\n</li>\n</ul>\n<p><strong>常对象：</strong></p>\n<ul>\n<li>\n<p>声明对象前加 const 称该对象为常对象</p>\n</li>\n<li>\n<p>常对象只能调用常函数，因为普通函数是可以修改成员属性的</p>\n</li>\n</ul>\n<h3 id=\"44-友元\"><a class=\"anchor\" href=\"#44-友元\">#</a> 4.4 友元</h3>\n<p>场景：生活中你的家有客厅（Public），有你的卧室（Private）</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性，也想让类外的一些函数或者类进行访问，就需要用到 友元 的技术</p>\n<p>友元 的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>关键字： <code>friend</code></p>\n<p>友元的三种实现：</p>\n<ul>\n<li>\n<p>全局函数做友元</p>\n</li>\n<li>\n<p>类做友元</p>\n</li>\n<li>\n<p>成员函数做友元</p>\n</li>\n</ul>\n<ol>\n<li>全局函数做友元: <code>friend void goodGy(Building&amp; building);</code></li>\n</ol>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 建筑物类</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Building</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">//goodGay 是 Building 的好朋友，可以访问私有成员</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">friend</span> <span class=\"token keyword\">void</span> <span class=\"token function\">goodGay</span><span class=\"token punctuation\">(</span>Building<span class=\"token operator\">&amp;</span> building<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">Building</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        m_SittingRoom <span class=\"token operator\">=</span> <span class=\"token string\">\"客厅\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        m_BedRoom <span class=\"token operator\">=</span> <span class=\"token string\">\"卧室\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    string m_SittingRoom<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    string m_BedRoom<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">// 全局函数</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">goodGy</span><span class=\"token punctuation\">(</span>Building<span class=\"token operator\">&amp;</span> building<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"好基友的全局函数访问SittingRoom\"</span> <span class=\"token operator\">&lt;&lt;</span> building<span class=\"token punctuation\">.</span>m_SittingRoom <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"好基友的全局函数访问BedRoom\"</span> <span class=\"token operator\">&lt;&lt;</span> building<span class=\"token punctuation\">.</span>m_BedRoom <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"2\">\n<li>类做友元：GoodGay 可以访问 Building 中的私有属性</li>\n</ol>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Building</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">friend</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GoodGay</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"3\">\n<li>成员函数做友元</li>\n</ol>\n<p><code>friend void GoodGay::visit();</code>  注意要注明是哪个类的成员函数。</p>\n<h3 id=\"45-运算符重载\"><a class=\"anchor\" href=\"#45-运算符重载\">#</a> 4.5 运算符重载</h3>\n<p>概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>\n<h4 id=\"451-加号运算符重载\"><a class=\"anchor\" href=\"#451-加号运算符重载\">#</a> 4.5.1 加号运算符重载</h4>\n<ul>\n<li>运算符重载，也可以发生函数重载</li>\n</ul>\n<p>成员函数的运算符重载</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Person <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>Person<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        Person temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        temp<span class=\"token punctuation\">.</span>m_A <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m_A <span class=\"token operator\">+</span> p<span class=\"token punctuation\">.</span>m_A<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        temp<span class=\"token punctuation\">.</span>m_B <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m_B <span class=\"token operator\">+</span> p<span class=\"token punctuation\">.</span>m_B<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>全局函数的运算符重载</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Person <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>Person<span class=\"token operator\">&amp;</span> p1<span class=\"token punctuation\">,</span> Person<span class=\"token operator\">&amp;</span> p2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    Person temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    temp<span class=\"token punctuation\">.</span>m_A <span class=\"token operator\">=</span> p1<span class=\"token punctuation\">.</span>m_A <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>m_A<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    temp<span class=\"token punctuation\">.</span>m_B <span class=\"token operator\">=</span> p1<span class=\"token punctuation\">.</span>m_B <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>m_B<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><blockquote>\n<p>对于内置的数据类型的表达式的运算符是不可能改变的</p>\n<p>不要滥用运算符重载</p>\n</blockquote>\n<h4 id=\"452-左移运算符重载\"><a class=\"anchor\" href=\"#452-左移运算符重载\">#</a> 4.5.2 左移运算符重载</h4>\n<p>因为成员函数无法实现 cout 在左侧，因此一般不使用其重载</p>\n<p>而使用全局函数进行重载</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ostream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>ostream<span class=\"token operator\">&amp;</span> cout<span class=\"token punctuation\">,</span> Person<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"m_A = \"</span> <span class=\"token operator\">&lt;&lt;</span> p<span class=\"token punctuation\">.</span>m_A <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\tm_B = \"</span> <span class=\"token operator\">&lt;&lt;</span> p<span class=\"token punctuation\">.</span>m_B<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> cout<span class=\"token punctuation\">;</span><span class=\"token comment\">// 链式编程思想</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果要访问类中的私有属性，可以使用友元的方式，将全局函数作为访问类的友元</p>\n<blockquote>\n<p>重载左移运算符配合友元可以实现输出自定义数据类型</p>\n</blockquote>\n<h4 id=\"453-递增运算符重载\"><a class=\"anchor\" href=\"#453-递增运算符重载\">#</a> 4.5.3 递增运算符重载</h4>\n<ol>\n<li>前置递增</li>\n</ol>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>MyInteger<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">++</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        m_Num<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">// 返回自身</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"2\">\n<li>后置递增</li>\n</ol>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>MyInteger <span class=\"token keyword\">operator</span><span class=\"token operator\">++</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token comment\">// 先 记录当时结果</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        MyInteger temp <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 后 递增</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        m_Num<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token comment\">// 最后将记录结果做返回</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">return</span> temp<span class=\"token punctuation\">;</span><span class=\"token comment\">// 后置递增，返回值</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"454-赋值运算符重载\"><a class=\"anchor\" href=\"#454-赋值运算符重载\">#</a> 4.5.4 赋值运算符重载</h4>\n<p>默认情况下，c++ 编译器至少给一个类添加 4 个函数</p>\n<ol>\n<li>\n<p>默认构造函数（无参，函数体为空）</p>\n</li>\n<li>\n<p>默认析构函数（函数体为空）</p>\n</li>\n<li>\n<p>默认拷贝函数，对属性进行值拷贝</p>\n</li>\n<li>\n<p>赋值运算符 operator=，对其属性进行值拷贝</p>\n</li>\n</ol>\n<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 重载赋值运算符</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    Person<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>Person<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">// 应该先判断是否有属性在堆区</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m_Age <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token keyword\">delete</span> m_Age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            m_Age <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token comment\">// 深拷贝</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m_Age <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">.</span>m_Age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"455-关系运算符重载\"><a class=\"anchor\" href=\"#455-关系运算符重载\">#</a> 4.5.5 关系运算符重载</h4>\n<p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">!=</span><span class=\"token punctuation\">(</span>Person<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m_Name <span class=\"token operator\">==</span> p<span class=\"token punctuation\">.</span>m_Name <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m_Age <span class=\"token operator\">==</span> p<span class=\"token punctuation\">.</span>m_Age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"456-函数调用运算符重载\"><a class=\"anchor\" href=\"#456-函数调用运算符重载\">#</a> 4.5.6 函数调用运算符重载</h4>\n<ul>\n<li>\n<p>函数调用运算符 () 也可以重载</p>\n</li>\n<li>\n<p>但是重载后使用的方式非常像函数的调用，因此也被成为 仿函数</p>\n</li>\n<li>\n<p>仿函数 没有固定写法，非常灵活</p>\n</li>\n</ul>\n<h3 id=\"46-继承\"><a class=\"anchor\" href=\"#46-继承\">#</a> 4.6 继承</h3>\n<p><strong>继承是面向对象三大特性之一</strong></p>\n<p>有些类与类之间存在特殊关系：</p>\n<figure class=\"highlight mermaid\"><figcaption data-lang=\"mermaid\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">graph</span> TD</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>A<span class=\"token text string\">(动物)</span><span class=\"token arrow operator\">---</span>B<span class=\"token text string\">(猫)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>A<span class=\"token arrow operator\">---</span>C<span class=\"token text string\">(狗)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>B<span class=\"token arrow operator\">---</span>B1<span class=\"token text string\">(加菲猫)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>B<span class=\"token arrow operator\">---</span>B2<span class=\"token text string\">(布偶猫)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>B<span class=\"token arrow operator\">---</span>B3<span class=\"token text string\">(波斯猫)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>C<span class=\"token arrow operator\">---</span>C1<span class=\"token text string\">(哈士奇)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>C<span class=\"token arrow operator\">---</span>C2<span class=\"token text string\">(京巴)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>C<span class=\"token arrow operator\">---</span>C3<span class=\"token text string\">(牧羊犬)</span></pre></td></tr></table></figure><p>这些类，下级别的成员拥有除了上一级的共性，还有自己的特性</p>\n<p>如果利用继承的技术，减少重复代码</p>\n<h4 id=\"461-继承的基本语法\"><a class=\"anchor\" href=\"#461-继承的基本语法\">#</a> 4.6.1 继承的基本语法</h4>\n<p>很多网站中，都有公共的头部，公共的底部</p>\n<p>语法： <code>class 子类:继承方式 父类</code></p>\n<p>继承的好处：减少重复代码</p>\n<blockquote>\n<p>子类 也称为 派生类</p>\n<p>父类 也称为 基类</p>\n</blockquote>\n<p><strong>派生类中的成员，包含两大部分：</strong></p>\n<p>一类是从基类继承过来的，一类是自己增加的成员</p>\n<p>从基类继承过来的表现其共性，而新增的成员体现了其个性</p>\n<h4 id=\"462-继承方式\"><a class=\"anchor\" href=\"#462-继承方式\">#</a> 4.6.2 继承方式</h4>\n<p>语法： <code>class 子类:继承方式 父类</code></p>\n<p><strong>继承方式一共有三种：</strong></p>\n<ul>\n<li>\n<p>公共继承</p>\n</li>\n<li>\n<p>保护继承</p>\n</li>\n<li>\n<p>私有继承</p>\n</li>\n</ul>\n<h4 id=\"463-继承中的对象模型\"><a class=\"anchor\" href=\"#463-继承中的对象模型\">#</a> 4.6.3 继承中的对象模型</h4>\n<p>问题：从父类继承过来的成员，哪些属于子类对象中？</p>\n<ul>\n<li>\n<p>父类中所有非静态成员属性，都会被子类继承；</p>\n</li>\n<li>\n<p>父类中私有成员属性 是被编译器给隐藏了， 因此是访问不到，但是确实被继承下去了</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> m_A<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">protected</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> m_B<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">int</span> m_C<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Son1</span> <span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">int</span> m_D<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">test01</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token comment\">//16</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"size of Son1 = \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Son1<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>给出如下工具查看 Son1 占用内存大小：</p>\n<h4 id=\"464-继承中构造和析构顺序\"><a class=\"anchor\" href=\"#464-继承中构造和析构顺序\">#</a> 4.6.4 继承中构造和析构顺序</h4>\n<p>子类继承父类后，当创建子类对象时，也会调用父类的构造函数</p>\n<p>问题：父类和子类的构造和析构顺序是怎样的呢</p>\n<p>和类的嵌套使用相似，先有父类构造，然后子类构造，子类先析构，然后父类析构</p>\n<h4 id=\"465-继承同名成员处理方式\"><a class=\"anchor\" href=\"#465-继承同名成员处理方式\">#</a> 4.6.5 继承同名成员处理方式</h4>\n<p>问题：当子类和父类出现同名的成员，如何通过子类对象， 访问到子类或父类中同名的数据呢</p>\n<ul>\n<li>\n<p>访问子类同名成员，直接访问即可</p>\n</li>\n<li>\n<p>访问父类同名成员，需要加作用域</p>\n</li>\n</ul>\n<p>如果出现同名成员函数，子类无法直接调用父类的重载函数，想继续访问，就加作用域</p>\n<blockquote>\n<p>如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数</p>\n</blockquote>\n<h4 id=\"466-继承同名静态成员处理\"><a class=\"anchor\" href=\"#466-继承同名静态成员处理\">#</a> 4.6.6 继承同名静态成员处理</h4>\n<p>与成员函数同名处理方式一致</p>\n<ul>\n<li>\n<p>访问子类同名成员，直接访问即可</p>\n</li>\n<li>\n<p>访问父类同名成员，需要加作用域</p>\n</li>\n</ul>\n<p>静态成员变量：类内声明，<strong>类外初始化</strong>（要注意声明作用域）；编译阶段分配内存；所有对象共享同一份数据</p>\n<p>注：静态成员有两种访问方式，通过对象和通过类名</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>s<span class=\"token punctuation\">.</span>Base<span class=\"token double-colon punctuation\">::</span>m_A</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Son<span class=\"token double-colon punctuation\">::</span>Base<span class=\"token double-colon punctuation\">::</span>m_A</pre></td></tr></table></figure><h4 id=\"467-多继承语法\"><a class=\"anchor\" href=\"#467-多继承语法\">#</a> 4.6.7 多继承语法</h4>\n<p>c++ 允许一个类继承多个类</p>\n<p>语法： <code>class 子类:继承方式 父类1, 继承方式 父类2...</code></p>\n<p>多继承中会引发父类中有同名成员出现，需要加作用域区分</p>\n<p>因此开发中不建议使用此类语法</p>\n<h4 id=\"468-菱形继承\"><a class=\"anchor\" href=\"#468-菱形继承\">#</a> 4.6.8 菱形继承</h4>\n<p><strong>菱形继承概念：</strong></p>\n<p>两个派生类继承同一个基类</p>\n<p>又有某个类同时继承两个派生类</p>\n<p>这种继承被称为菱形继承、或者钻石继承</p>\n<p>问题：这个某个类继承基类数据，继承了两份，这份数据只需要一份就行</p>\n<p>解决：<strong>利用虚继承，解决菱形继承的问题</strong></p>\n<p>在第一次继承前加关键字 virtual，此时基类称为虚基类</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> m_Age<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Sheep</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">virtual</span> <span class=\"token keyword\">public</span> <span class=\"token class-name\">Animal</span></span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Tuo</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">virtual</span> <span class=\"token keyword\">public</span> <span class=\"token class-name\">Animal</span></span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">SheepTuo</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token class-name\">pubilc</span> <span class=\"token class-name\">Sheep</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">public</span> <span class=\"token class-name\">Tuo</span></span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"47-多态\"><a class=\"anchor\" href=\"#47-多态\">#</a> 4.7 多态</h3>\n<h4 id=\"471-多态的基本概念\"><a class=\"anchor\" href=\"#471-多态的基本概念\">#</a> 4.7.1 多态的基本概念</h4>\n<p>多态是 c++ 面向对象三大特征之一</p>\n<p>多态分两类：</p>\n<ul>\n<li>\n<p>静态多态：函数重载和运算符重载属于静态多态，复用函数名</p>\n</li>\n<li>\n<p>动态多态：派生类和虚函数实现运行时多态</p>\n</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>\n<p>静态：函数地址早绑定 - 编译阶段确定函数地址（静态联编）</p>\n</li>\n<li>\n<p>动态：函数地址晚绑定 - 运行阶段确定函数地址（动态联编）</p>\n</li>\n</ul>\n<p><strong>动态多态满足条件：</strong></p>\n<ol>\n<li>\n<p>有继承关系</p>\n</li>\n<li>\n<p>子类 重写 父类的虚函数</p>\n</li>\n<li>\n<blockquote>\n<p>重写：函数返回值类型 函数名 参数列表 完全相同 子类 virtual 加不加都行</p>\n</blockquote>\n</li>\n</ol>\n<p>使用：</p>\n<ul>\n<li>父类的指针或引用 执行子类的对象</li>\n</ul>\n<p><strong>指针 4 个字节，32 位系统</strong></p>\n<p>子类在继承时，或覆盖虚函数表指针指向的虚函数表，将父类中的虚函数地址覆盖为自身重写的函数地址</p>\n<h4 id=\"472-多态案例1-计算器类\"><a class=\"anchor\" href=\"#472-多态案例1-计算器类\">#</a> 4.7.2 多态案例 1 - 计算器类</h4>\n<p>多态的优点：</p>\n<ul>\n<li>\n<p>代码组织结构清晰</p>\n</li>\n<li>\n<p>可读性强</p>\n</li>\n<li>\n<p>利于前期和后期的扩展以及维护</p>\n</li>\n</ul>\n<h4 id=\"473-纯虚函数和抽象类\"><a class=\"anchor\" href=\"#473-纯虚函数和抽象类\">#</a> 4.7.3 纯虚函数和抽象类</h4>\n<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>\n<p>因此也可以将虚函数改为纯虚函数</p>\n<p>纯虚函数的语法： <code>virtual 返回值类型 函数名(参数列表) = 0;</code></p>\n<p>当类中有纯虚函数 ，这个类也成为抽象类</p>\n<p>抽象类特点：</p>\n<ul>\n<li>\n<p>无法实例化对象</p>\n</li>\n<li>\n<p>子类必须重写抽象类中的纯虚函数，否写也属于抽象类</p>\n</li>\n</ul>\n<h4 id=\"475-虚析构和纯虚析构\"><a class=\"anchor\" href=\"#475-虚析构和纯虚析构\">#</a> 4.7.5 虚析构和纯虚析构</h4>\n<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>\n<p>解决方式：将父类中的析构函数改为 <strong>虚析构</strong>或者<strong>纯虚析构</strong></p>\n<blockquote>\n<p>如果子类中没有堆区数据，可以不写虚析构或纯虚析构</p>\n</blockquote>\n<p>虚析构和纯虚析构共性：</p>\n<ul>\n<li>\n<p>可以解决父类指针释放子类对象</p>\n</li>\n<li>\n<p>都需要有具体的函数实现</p>\n</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>如果是纯虚析构，改类属于抽象类，无法实例化对象</li>\n</ul>\n<p>虚析构语法： <code>virtual ~类名()&#123;&#125;</code></p>\n<p>纯虚析构语法： <code>virtual ~类名() = 0;</code>  还要有实现</p>\n<h2 id=\"5-文件操作\"><a class=\"anchor\" href=\"#5-文件操作\">#</a> 5 文件操作</h2>\n<p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>\n<p>通过<strong>文件可以将数据持久化</strong></p>\n<p>c++ 中对文件操作需要包含头文件</p>\n<p>文件类型分为两种：</p>\n<ol>\n<li>\n<p><strong>文本文件</strong> - 文本以 ASCII 码存储在计算机中</p>\n</li>\n<li>\n<p><strong>二进制文件</strong> - 以二进制形式存储在计算机中，用户一般不直接读懂他们</p>\n</li>\n</ol>\n<p>操作文件的三大类：</p>\n<ol>\n<li>\n<p>ofstream: 写操作</p>\n</li>\n<li>\n<p>ifstream：读操作</p>\n</li>\n<li>\n<p>fstream：读写操作</p>\n</li>\n</ol>\n<h3 id=\"51-文本文件\"><a class=\"anchor\" href=\"#51-文本文件\">#</a> 5.1 文本文件</h3>\n<h4 id=\"511-写文件\"><a class=\"anchor\" href=\"#511-写文件\">#</a> 5.1.1 写文件</h4>\n<p>步骤：</p>\n<ol>\n<li>\n<p><code>#include&lt;fstream&gt;;</code></p>\n</li>\n<li>\n<p>创建流对象： <code>ofstream ofs;</code></p>\n</li>\n<li>\n<p>打开方式  <code>ofs.open(&quot;文件路径&quot;,打开方式);</code></p>\n</li>\n<li>\n<p>写数据  <code>ofs&lt;&lt;&quot;写入的数据&quot;;</code></p>\n</li>\n<li>\n<p>关闭文件  <code>ofs.close();</code></p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>打开方式</strong></th>\n<th><strong>解释</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ios::in</td>\n<td>读文件</td>\n</tr>\n<tr>\n<td>ios::out</td>\n<td>写文件</td>\n</tr>\n<tr>\n<td>ios::ate</td>\n<td>初始位置：文件尾</td>\n</tr>\n<tr>\n<td>ios::app</td>\n<td>追加方式写文件</td>\n</tr>\n<tr>\n<td>ios::trunc</td>\n<td>如果文件存在先删除，再创建</td>\n</tr>\n<tr>\n<td>ios::binary</td>\n<td>二进制方式</td>\n</tr>\n</tbody>\n<tbody>\n<tr>\n<td>注意：问价按打开方式可以配合使用，利用</td>\n<td>操作符</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"512-读文件\"><a class=\"anchor\" href=\"#512-读文件\">#</a> 5.1.2 读文件</h4>\n<p>注意判断是否打开成功</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ifs<span class=\"token punctuation\">.</span><span class=\"token function\">is_open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>四种方式读取</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>ifs<span class=\"token operator\">>></span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    cout<span class=\"token operator\">&lt;&lt;</span>buf<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>ifs<span class=\"token punctuation\">.</span><span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    cout<span class=\"token operator\">&lt;&lt;</span>buf<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>string buf<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>ifs<span class=\"token punctuation\">,</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    cout<span class=\"token operator\">&lt;&lt;</span>buf<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">//EOF end of file</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">char</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">=</span> ifs<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span><span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    cout<span class=\"token operator\">&lt;&lt;</span>c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"52-二进制文件\"><a class=\"anchor\" href=\"#52-二进制文件\">#</a> 5.2 二进制文件</h3>\n<p>以二进制的方式对文件进行读写操作</p>\n<p>打开方式： <code>ios::binary</code></p>\n<h4 id=\"521-写文件\"><a class=\"anchor\" href=\"#521-写文件\">#</a> 5.2.1 写文件</h4>\n<p>利用流对象调用成员函数 write</p>\n<p>函数原型： <code>ostream&amp; write(const char * buffer,int len);</code></p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 时读写的字节数</p>\n<h4 id=\"522-读文件\"><a class=\"anchor\" href=\"#522-读文件\">#</a> 5.2.2 读文件</h4>\n<p>利用流对象调用成员函数 read</p>\n<p>函数原型： <code>istream&amp; read(char *buffer,int len);</code></p>\n<p>参数解释：字符指针 buffer 指向内存中的一段存储空间，len 是读写的字节数</p>\n",
            "tags": [
                "c++学习"
            ]
        },
        {
            "id": "https://killer1214.github.io/2023/04/03/c-base-learn/",
            "url": "https://killer1214.github.io/2023/04/03/c-base-learn/",
            "title": "c++base_learn",
            "date_published": "2023-04-03T13:14:48.000Z",
            "content_html": "<h1 id=\"c基础\"><a class=\"anchor\" href=\"#c基础\">#</a> c++ 基础</h1>\n<h2 id=\"1c了解\"><a class=\"anchor\" href=\"#1c了解\">#</a> 1.c++ 了解</h2>\n<h2 id=\"2数据类型\"><a class=\"anchor\" href=\"#2数据类型\">#</a> 2. 数据类型</h2>\n<h3 id=\"25-转义字符\"><a class=\"anchor\" href=\"#25-转义字符\">#</a> 2.5 转义字符</h3>\n<ul>\n<li>\n<p>\\t 水平制表（HT）（跳到下一个 tab 位置，一个 tab 占 8 个位置）009</p>\n</li>\n<li>\n<p>\\n 换行（LF）010</p>\n</li>\n<li>\n<p>\\r 回车（CR）回到当前行开头 013</p>\n</li>\n</ul>\n<h3 id=\"26字符串型\"><a class=\"anchor\" href=\"#26字符串型\">#</a> 2.6 字符串型</h3>\n<p>作用：表示一串字符</p>\n<h4 id=\"1c风格字符串char-变量名-字符串值\"><a class=\"anchor\" href=\"#1c风格字符串char-变量名-字符串值\">#</a> 1.C 风格字符串： <code>char 变量名[] = &quot;字符串值&quot;</code></h4>\n<p>例如： <code>char str1[] = &quot;hello,world&quot;;</code></p>\n<h4 id=\"2c风格字符串string-变量名-字符串值\"><a class=\"anchor\" href=\"#2c风格字符串string-变量名-字符串值\">#</a> 2.c++ 风格字符串： <code>string 变量名 = &quot;字符串值&quot;</code></h4>\n<p>例如： <code>string str2 = &quot;hello world&quot;;</code></p>\n<p><strong>注意</strong>：需要包含头文件 <code>#include &lt;string&gt;</code></p>\n<h3 id=\"27布尔类型bool\"><a class=\"anchor\" href=\"#27布尔类型bool\">#</a> 2.7 布尔类型 bool</h3>\n<p><strong>作用</strong>：布尔数据类型代表真或假的值</p>\n<p>bool 类型只有两个值：</p>\n<ul>\n<li>\n<p>true ----- 真（本质是 1）// 非零值都代表真</p>\n</li>\n<li>\n<p>false----- 假（本质是 0）</p>\n</li>\n</ul>\n<p>bool 类型占 1 个字节大小</p>\n<p>示例： <code>bool flag = true;//true代表真，此时flag==1</code></p>\n<h3 id=\"28数据的输入\"><a class=\"anchor\" href=\"#28数据的输入\">#</a> 2.8 数据的输入</h3>\n<p>作用：从键盘获取数据</p>\n<p>关键字：cin</p>\n<p>语法： <code>cin &gt;&gt; 变量</code></p>\n<h2 id=\"3运算符\"><a class=\"anchor\" href=\"#3运算符\">#</a> 3. 运算符</h2>\n<p>作用：用于执行代码的运算</p>\n<table>\n<thead>\n<tr>\n<th>运算符类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>算数运算符</td>\n<td>处理四则运算</td>\n</tr>\n<tr>\n<td>赋值运算符</td>\n<td>将表达式的值赋给变量</td>\n</tr>\n<tr>\n<td>比较运算符</td>\n<td>表达式的比较，并返回一个真值或假值</td>\n</tr>\n<tr>\n<td>逻辑运算符</td>\n<td>根据表达式的值返回真值或假值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"31算数运算符\"><a class=\"anchor\" href=\"#31算数运算符\">#</a> 3.1 算数运算符</h3>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>术语</th>\n<th>示例</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>正号</td>\n<td>+3</td>\n<td>3</td>\n</tr>\n<tr>\n<td>-</td>\n<td>负号</td>\n<td>-3</td>\n<td>-3</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加</td>\n<td>2+3</td>\n<td>5</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减</td>\n<td>5-2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘</td>\n<td>2*3</td>\n<td>6</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除以</td>\n<td>10/5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模（取余）</td>\n<td>10%3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>++</td>\n<td>前置递增</td>\n<td>a=2;b=++a;</td>\n<td>a=3;b=3;</td>\n</tr>\n<tr>\n<td>++</td>\n<td>后置递增</td>\n<td>a=2;b=a++;</td>\n<td>a=3;b=2;</td>\n</tr>\n<tr>\n<td>--</td>\n<td>前置递减</td>\n<td>a=2;b=--a;</td>\n<td>a=1;b=1;</td>\n</tr>\n<tr>\n<td>--</td>\n<td>后置递减</td>\n<td>a=2;b=a--;</td>\n<td>a=1;b=2;</td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<ul>\n<li>\n<p>两个整数相除，结果依然是<strong>整数</strong>，将小数部分去除</p>\n</li>\n<li>\n<p>除数不能是 0</p>\n</li>\n<li>\n<p>小数除法运算，结果优先显示为整数（小数部分为零时省略显示）</p>\n</li>\n<li>\n<p>两个小数不允许做取模运算</p>\n</li>\n<li>\n<p>前置：先对变量处理，然后进行表达式运算；后置：先进行表达式运算，然后对变量处理</p>\n</li>\n</ul>\n<h3 id=\"32赋值运算符\"><a class=\"anchor\" href=\"#32赋值运算符\">#</a> 3.2 赋值运算符</h3>\n<p>作用：将表达式的值赋给变量</p>\n<p>运算符： <code>=，+=，-=，*=，/=，%=</code></p>\n<h3 id=\"33比较运算符\"><a class=\"anchor\" href=\"#33比较运算符\">#</a> 3.3 比较运算符</h3>\n<p>作用：用于表达式的比较，并返回一个真值（1）或假值（0）</p>\n<p>运算符： <code>==，!=，&lt;，&gt;，&lt;=，&gt;=</code></p>\n<h3 id=\"34逻辑运算符\"><a class=\"anchor\" href=\"#34逻辑运算符\">#</a> 3.4 逻辑运算符</h3>\n<p>作用：用于根据表达式的值返回真值或假值</p>\n<p>运算符： <code>!,&amp;&amp;,||</code></p>\n<h2 id=\"4程序流程结构\"><a class=\"anchor\" href=\"#4程序流程结构\">#</a> 4. 程序流程结构</h2>\n<p>顺序结构，选择结构，循环结构</p>\n<ul>\n<li>\n<p>顺序结构：程序顺序执行，不发生跳转</p>\n</li>\n<li>\n<p>选择结构：依据条件是否满足，有选择 的执行相应功能</p>\n</li>\n<li>\n<p>循环结构：依据条件是否满足，循环多次执行某段代码</p>\n</li>\n</ul>\n<h3 id=\"41选择结构\"><a class=\"anchor\" href=\"#41选择结构\">#</a> 4.1 选择结构</h3>\n<h4 id=\"411-if语句\"><a class=\"anchor\" href=\"#411-if语句\">#</a> 4.1.1 if 语句</h4>\n<p>if 语句的三种形式：</p>\n<ul>\n<li>\n<p>单行格式 if 语句（无 else）</p>\n</li>\n<li>\n<p>多行格式 if 语句（有 else）</p>\n</li>\n<li>\n<p>多条件的 if 语句</p>\n</li>\n</ul>\n<h4 id=\"412三目运算符\"><a class=\"anchor\" href=\"#412三目运算符\">#</a> 4.1.2 三目运算符</h4>\n<p>作用：通过三目运算符实现简单的判断</p>\n<p>语法： <code>表达式1?表达式2:表达式3</code></p>\n<p>如果表达式 1 为<strong>真</strong>，则执行<strong>表达式 2</strong>，并返回表达式 2 的结果</p>\n<p>如果表达式 1 为<strong>假</strong>，则执行<strong>表达式 3</strong>，并返回表达式 3 的结果</p>\n<p>补充：在 C++ 中三目运算符返回的是变量，可以继续赋值</p>\n<p>例如： <code>(a &gt; b ? a : b) = 100</code></p>\n<h4 id=\"413switch语句\"><a class=\"anchor\" href=\"#413switch语句\">#</a> 4.1.3switch 语句</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>表达式<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">case</span> 结果<span class=\"token number\">1</span><span class=\"token operator\">:</span>执行语句<span class=\"token punctuation\">;</span><span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">case</span> 结果<span class=\"token number\">2</span><span class=\"token operator\">:</span>执行语句<span class=\"token punctuation\">;</span><span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>执行语句<span class=\"token punctuation\">;</span><span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意：case 里如果没有 break，那么程序会一直向下执行</p>\n<p><strong>if 和 switch 区别：</strong></p>\n<ul>\n<li>\n<p>switch 缺点，判断的时候只能是整型或者字符型，不可以是一个区间</p>\n</li>\n<li>\n<p>switch 优点，结构清晰执行效率高</p>\n</li>\n</ul>\n<h3 id=\"42循环结构\"><a class=\"anchor\" href=\"#42循环结构\">#</a> 4.2 循环结构</h3>\n<h4 id=\"421while循环语句\"><a class=\"anchor\" href=\"#421while循环语句\">#</a> 4.2.1while 循环语句</h4>\n<p>语法： <code>while(循环条件)&#123;循环语句&#125;</code></p>\n<p>只要循环条件结果为真，就执行循环语句</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;ctime></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 依据当前系统时间来添加随机数种子</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">srand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 需要 ctime 头文件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">100</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 生成 1~100 随机数</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"422-dowhile循环语句\"><a class=\"anchor\" href=\"#422-dowhile循环语句\">#</a> 4.2.2 do...while 循环语句</h4>\n<p>语法： <code>do&#123;循环语句&#125;while(循环条件)</code></p>\n<p>注意：与 while 的区别在于 do...while 会先执行一次循环语句，再判断循环条件</p>\n<h4 id=\"423-for循环语句\"><a class=\"anchor\" href=\"#423-for循环语句\">#</a> 4.2.3 for 循环语句</h4>\n<p>语法： <code>for(起始表达式;条件表达式;末尾循环体)&#123;循环语句&#125;</code></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/* 敲桌子，1~100 内，各位 7 (mod10=7)，</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>十位 7 (/10 = 7)，</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>或者是 7 的倍数 (mod7=0)，</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>则输出敲桌子 */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">%</span><span class=\"token number\">7</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token operator\">||</span>i<span class=\"token operator\">%</span><span class=\"token number\">10</span><span class=\"token operator\">==</span><span class=\"token number\">7</span><span class=\"token operator\">||</span>i<span class=\"token operator\">/</span><span class=\"token number\">10</span><span class=\"token operator\">==</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"敲桌子\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">system</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pause\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"424嵌套循环\"><a class=\"anchor\" href=\"#424嵌套循环\">#</a> 4.2.4 嵌套循环</h4>\n<h3 id=\"43跳转语句\"><a class=\"anchor\" href=\"#43跳转语句\">#</a> 4.3 跳转语句</h3>\n<h4 id=\"431-break语句\"><a class=\"anchor\" href=\"#431-break语句\">#</a> 4.3.1 break 语句</h4>\n<p>作用：跳出选择结构或者循环结构</p>\n<p>break 使用的时机：</p>\n<ul>\n<li>\n<p>switch 条件语句中，终止 case 并跳出 switch</p>\n</li>\n<li>\n<p>循环语句中，跳出当前的循环语句</p>\n</li>\n<li>\n<p>嵌套循环中，跳出最近的内层循环语句</p>\n</li>\n</ul>\n<h4 id=\"432-continue语句\"><a class=\"anchor\" href=\"#432-continue语句\">#</a> 4.3.2 continue 语句</h4>\n<p>作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>\n<h4 id=\"433-goto语句\"><a class=\"anchor\" href=\"#433-goto语句\">#</a> 4.3.3 goto 语句</h4>\n<p>作用：可以<strong>无条件</strong>跳转语句</p>\n<p>语法： <code>goto 标记;</code> (标记习惯用全大写)</p>\n<p>解释：如果标记的名称存在，执行到 goto 语句时，会跳转到标记的位置</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">goto</span> FLAG<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>FLAG<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><h2 id=\"5-数组\"><a class=\"anchor\" href=\"#5-数组\">#</a> 5 数组</h2>\n<h3 id=\"51-概述\"><a class=\"anchor\" href=\"#51-概述\">#</a> 5.1 概述</h3>\n<p>数组，就是一个集合，里面存放了相同类型的数据元素</p>\n<p><strong>特点 1</strong>：数组中的每个数据元素都是相同的数据类型</p>\n<p><strong>特点 2</strong>：数组是由连续的内存位置组成的</p>\n<h3 id=\"52-一维数组\"><a class=\"anchor\" href=\"#52-一维数组\">#</a> 5.2 一维数组</h3>\n<h4 id=\"521-一维数组定义方式\"><a class=\"anchor\" href=\"#521-一维数组定义方式\">#</a> 5.2.1 一维数组定义方式</h4>\n<p>三种方式：</p>\n<ol>\n<li>\n<p><code>数据类型 数组名[数组长度];</code></p>\n</li>\n<li>\n<p><code>数据类型 数组名[数组长度] = &#123;值1, 值2...&#125;;</code> (没有全部初始化的后续空间会用 0 填补)</p>\n</li>\n<li>\n<p><code>数据类型 数组名[] = &#123;值1, 值2...&#125;;</code></p>\n</li>\n</ol>\n<h4 id=\"522-一维数组数组名\"><a class=\"anchor\" href=\"#522-一维数组数组名\">#</a> 5.2.2 一维数组数组名</h4>\n<p>用途：</p>\n<ol>\n<li>\n<p>统计整个数组在内存中的长度 <code>sizeof(数组名)</code></p>\n</li>\n<li>\n<p>获取数组在内存中的首地址 <code>cout &lt;&lt; 数组名</code></p>\n</li>\n</ol>\n<h4 id=\"523-冒泡排序\"><a class=\"anchor\" href=\"#523-冒泡排序\">#</a> 5.2.3 冒泡排序</h4>\n<ul>\n<li>\n<p>总排序轮数 = 元素个数 - 1</p>\n</li>\n<li>\n<p>内层循环对比次数 = 元素个数 - 当前轮数 - 1</p>\n</li>\n</ul>\n<h3 id=\"53-二维数组\"><a class=\"anchor\" href=\"#53-二维数组\">#</a> 5.3 二维数组</h3>\n<h4 id=\"531-二维数组定义方式\"><a class=\"anchor\" href=\"#531-二维数组定义方式\">#</a> 5.3.1 二维数组定义方式</h4>\n<p>四种定义方式：</p>\n<ol>\n<li>\n<p><code>数据类型 数组名[行数][列数];</code></p>\n</li>\n<li>\n<p><code>数据类型 数组名[行数][列数]=&#123;&#123;数据1,数据2&#125;,&#123;数据3,数据4&#125;&#125;;</code></p>\n</li>\n<li>\n<p><code>数据类型 数组名[行数][列数]=&#123;数据1,数据2,数据3,数据4&#125;;</code></p>\n</li>\n<li>\n<p><code>数据类型 数组名[ ][列数]=&#123;数据1,数据2,数据3,数据4&#125;;</code></p>\n</li>\n</ol>\n<h4 id=\"532-二维数组数组名\"><a class=\"anchor\" href=\"#532-二维数组数组名\">#</a> 5.3.2 二维数组数组名</h4>\n<p>用途：</p>\n<ol>\n<li>\n<p>查看二位数据所占用内存空间  <code>sizeof(数组名)</code></p>\n</li>\n<li>\n<p>获取二维数组首地址  <code>cout &lt;&lt; 数组名</code></p>\n</li>\n</ol>\n<h2 id=\"6函数\"><a class=\"anchor\" href=\"#6函数\">#</a> 6. 函数</h2>\n<h3 id=\"61-概述\"><a class=\"anchor\" href=\"#61-概述\">#</a> 6.1 概述</h3>\n<p>作用： 将一段经常使用的代码封装起来，减少重复代码</p>\n<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>\n<h3 id=\"62-函数的定义\"><a class=\"anchor\" href=\"#62-函数的定义\">#</a> 6.2 函数的定义</h3>\n<p>函数的定义一般主要有五个步骤：</p>\n<ol>\n<li>\n<p>返回值类型</p>\n</li>\n<li>\n<p>函数名</p>\n</li>\n<li>\n<p>参数表列</p>\n</li>\n<li>\n<p>函数体语句</p>\n</li>\n<li>\n<p>return 表达式</p>\n</li>\n</ol>\n<h3 id=\"63-函数的调用\"><a class=\"anchor\" href=\"#63-函数的调用\">#</a> 6.3 函数的调用</h3>\n<p>功能：使用定义好的函数</p>\n<p>语法： <code>函数名(参数)</code></p>\n<h3 id=\"64-值传递\"><a class=\"anchor\" href=\"#64-值传递\">#</a> 6.4 值传递</h3>\n<ul>\n<li>\n<p>值传递：函数调用时实参将数值传入给形参</p>\n</li>\n<li>\n<p>值传递时，如果形参发生改变，并不会影响实参</p>\n</li>\n</ul>\n<h3 id=\"65-函数的常见样式\"><a class=\"anchor\" href=\"#65-函数的常见样式\">#</a> 6.5 函数的常见样式</h3>\n<ol>\n<li>\n<p>无参无返</p>\n</li>\n<li>\n<p>有参无返</p>\n</li>\n<li>\n<p>无参有返</p>\n</li>\n<li>\n<p>有参有返</p>\n</li>\n</ol>\n<h3 id=\"66-函数的声明\"><a class=\"anchor\" href=\"#66-函数的声明\">#</a> 6.6 函数的声明</h3>\n<p>作用：告诉编译器函数名称以及如何调用函数。函数的实际主题可以单独定义</p>\n<ul>\n<li>函数的声明可以很多次 (没有必要)，但是函数的定义只能有一次</li>\n</ul>\n<p>示例： <code>int max(int a, int b);</code></p>\n<h3 id=\"67-函数的份文件编写\"><a class=\"anchor\" href=\"#67-函数的份文件编写\">#</a> 6.7 函数的份文件编写</h3>\n<p>作用：让代码结构更加清晰</p>\n<p>一般四个步骤：</p>\n<ol>\n<li>\n<p>创建后缀名为 .h 的头文件</p>\n</li>\n<li>\n<p>创建后缀名为 .cpp 的源文件</p>\n</li>\n<li>\n<p>在头文件中写函数的声明，包含 <code>include&lt;iostream&gt;</code>  和 <code>using namespace std;</code></p>\n</li>\n<li>\n<p>在源文件中写函数的定义，关联头文件 <code>include &quot;头文件名&quot;</code></p>\n</li>\n</ol>\n<h2 id=\"7指针\"><a class=\"anchor\" href=\"#7指针\">#</a> 7. 指针</h2>\n<h3 id=\"71-指针的基本概念\"><a class=\"anchor\" href=\"#71-指针的基本概念\">#</a> 7.1 指针的基本概念</h3>\n<p>指针的作用：可以通过指针间接访问内存</p>\n<ul>\n<li>\n<p>内存编号是从 0 开始记录的，一般用十六进制数字表示</p>\n</li>\n<li>\n<p>可以利用指针变量保存地址</p>\n</li>\n</ul>\n<h3 id=\"72-指针变量的定义和使用\"><a class=\"anchor\" href=\"#72-指针变量的定义和使用\">#</a> 7.2 指针变量的定义和使用</h3>\n<p>指针变量定义语法： <code>数据类型 *变量名;</code></p>\n<p>使用：通过解引用的方式来找到指针指向的内存，如 <code>*p</code></p>\n<h3 id=\"73-指针所占用内存空间\"><a class=\"anchor\" href=\"#73-指针所占用内存空间\">#</a> 7.3 指针所占用内存空间</h3>\n<p>在 32 位操作系统下：占用 4 个字节空间</p>\n<p>在 64 位操作系统下：占用 8 个字节空间</p>\n<h3 id=\"74-空指针和野指针\"><a class=\"anchor\" href=\"#74-空指针和野指针\">#</a> 7.4 空指针和野指针</h3>\n<p>空指针：指针变量指向内存中编号为 0 的空间</p>\n<p>用途：初始化指针变量</p>\n<p>注意：空指针指向的内存是<strong>不可以</strong>访问的（0~255 之间的内存编号是系统占用的）</p>\n<p>野指针：指针变量指向非法的内存空间</p>\n<blockquote>\n<p>在程序中，尽量避免出现野指针</p>\n</blockquote>\n<h3 id=\"75-const修饰指针\"><a class=\"anchor\" href=\"#75-const修饰指针\">#</a> 7.5 const 修饰指针</h3>\n<p>const 修饰指针有三种情况：</p>\n<ol>\n<li>\n<p>const 修饰指针 --- 常量指针</p>\n</li>\n<li>\n<p>const 修饰常量 --- 指针常量</p>\n</li>\n<li>\n<p>const 既修饰指针，又修饰常量</p>\n</li>\n</ol>\n<p>常量指针： <code>const int *p = &amp;a;</code></p>\n<blockquote>\n<p>指针的指向可以修改，但是指针指向的值不可以修改</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\" /><label for=\"cbx_0\"> *p = 20; 错误，指针指向的值不可以修改</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_1\"> p = &amp;b; 正确，指针的指向可以修改</label></p>\n</li>\n</ul>\n<p>指针常量： <code>int * const p = &amp;a;</code></p>\n<blockquote>\n<p>指针的指向不可以修改，指针指向的值可以修改</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_2\"> *p = 20; 正确，指针指向的值可以修改</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_3\" disabled=\"true\" /><label for=\"cbx_3\"> p = &amp;b; 错误，指针的指向不可以修改</label></p>\n</li>\n</ul>\n<p>const 既修饰指针，又修饰常量： <code>const int * const p = &amp;a;</code></p>\n<blockquote>\n<p>指针的指向和指针的值都不可以修改</p>\n</blockquote>\n<p>上述两种操作都是错误的</p>\n<h3 id=\"76-指针和数组\"><a class=\"anchor\" href=\"#76-指针和数组\">#</a> 7.6 指针和数组</h3>\n<p>利用指针访问数组中元素</p>\n<p>数组名本身就是一个指针</p>\n<h3 id=\"77-指针和函数\"><a class=\"anchor\" href=\"#77-指针和函数\">#</a> 7.7 指针和函数</h3>\n<p>作用：利用指针作函数参数，可以修改实参的值</p>\n<blockquote>\n<p>地址传递</p>\n</blockquote>\n<h3 id=\"78-指针-数组-函数\"><a class=\"anchor\" href=\"#78-指针-数组-函数\">#</a> 7.8 指针、数组、函数</h3>\n<p>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>\n",
            "tags": []
        },
        {
            "id": "https://killer1214.github.io/2023/04/03/hello-world/",
            "url": "https://killer1214.github.io/2023/04/03/hello-world/",
            "title": "Hello World",
            "date_published": "2023-04-03T08:05:31.632Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}